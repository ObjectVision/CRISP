container Templates
{
	Template GetDistance_T
	{
		unit<uint32> poly_set;
		///
	
		unit<uint32> segments := arc2segm(poly_set/Geometry_mer)
		, Descr = "to prepare for a pointset, we need to split up the lines into smaller segments to ensure enough points."
		{
			unit<uint32> pointset := union_unit(.,.)
			{
				attribute<SphericalMercator> point    := union_data(., ../point, ../nextpoint);
				attribute<..>                sequence := union_data(., id(..), id(..));
				attribute<uint32>            ordinal  := union_data(., const(0,..), const(1,..));
			}
			attribute<SphericalMercator> geometry_mer_segm (arc)   := points2sequence(pointset/point, pointset/sequence, pointset/ordinal);
		}
	
		unit<uint32> DynaPoints   := dyna_point_with_ends(segments/point, segments/nextpoint, 100d)
		, Descr ="Create pointset with small enough steps, say every 100m";
			
		unit<uint32> UqDynaPoints := unique(DynaPoints/point);

		unit<uint32> from_domain  := CompactedDomain 
		{
			attribute<SphericalMercator> geometry      := CompactedDomain/Geometry_mer;
			attribute<to_domain>         to_domain_rel := connect(to_domain/geometry, from_domain/geometry);
			attribute<SphericalMercator> geometry_to   := to_domain/geometry[to_domain_rel];
			attribute<float64>           sqrdist       := sqrdist(geometry_to, geometry);
		}

		unit<uint32> to_domain  := UqDynaPoints
		{
			attribute<SphericalMercator> geometry      := values;
		}
		
		attribute<float32> Location2_sqr         (CompactedDomain) := from_domain/sqrdist[float32]; 
		attribute<float32> Location2_sqr_domain_export    (domain) := Location2_sqr[CompactedDomain/BaseGrid];
	}


	Template potrange_T
	{
		//begin of case parameters
		parameter<km>      vertical_gridsize;
		parameter<km>      borderRadius;
		//end of case parameters
		unit<Float32> Potential;
		
		parameter<Float32> AspectRatio         := cos(Float32(pi()) * 30f / 180f); //assumption in LatLong: we expect most people live around 30 degrees. So this should be a representive grid 
		parameter<km>      horizontal_gridsize := vertical_gridsize * AspectRatio;
		parameter<float32> vertical_radius     := borderRadius / vertical_gridsize;
		parameter<float32> horizontal_radius   := borderRadius / horizontal_gridsize;
		
		unit<spoint>       potRange            := range(spoint, point_yx(-int16(vertical_radius), -int16(horizontal_radius)), point_yx(int16(vertical_radius) + int16(1), int16(horizontal_radius) + int16(1)))
		{
			attribute<Potential> distMatr          := Sqr(Float32(pointrow(ID(.)))) + Sqr(Float32(pointcol(ID(.)))*AspectRatio);
			attribute<km>        EuclideanDistMatr := Sqrt(distMatr)[km];
			attribute<float32>	 inv_EDM		   := EuclideanDistMatr[float32] <= vertical_radius ? 1f / max_elem(1f, EuclideanDistMatr[float32]) : 0f;
			// attribute<Potential> Weight            := interpolate_linear(EuclideanDistMatr * 1000[meter / km], value(Preprocessing/Suitability/DistanceBuildUp/Class/Distance_meter, meter), Float32(Preprocessing/Suitability/DistanceBuildUp/Class/PROBABILITY));
			// attribute<Potential> WeightCorr        := ID(.) == point_yx(0s, 0s) ? 0f : Weight;
			// attribute<Potential> RelWeightCorr     := scalesum(WeightCorr, 1f );
			
			attribute<Potential> AbsWeight         := iif(distMatr <= vertical_radius * vertical_radius, 1f / (distMatr + 0.08f), 0f);
			attribute<Potential> AbsWeight_noself  := distMatr > 0f ? AbsWeight : 0f;
			attribute<Potential> RelWeight         := scalesum(     AbsWeight , 1f );
			attribute<Potential> RelWeightSqrt     := scalesum(Sqrt(AbsWeight), 1f );
			attribute<Potential> RelWeight_ns      := scalesum(     AbsWeight_noself , 1f );
			attribute<Potential> RelWeightSqrt_ns  := scalesum(Sqrt(AbsWeight_noself), 1f );
			attribute<Potential> Conal             := scalesum(max_elem(vertical_radius - Sqrt(distMatr), 0f), 1f );
			
			attribute<Float32>   flat2             := Float32(distMatr <= (vertical_radius * vertical_radius));
			
			attribute<uint8>      buffer            := iif(distMatr <= vertical_radius * vertical_radius, 1b, 0b);
			
			unit<uint32> Buffer_NonNull_Cells := select_with_org_rel(buffer == 1b); 
		}
	}
	template ReadCubistModel {
		
		parameter<string>  filename := '%projdir%/data/TableChopper.csv';
		parameter<string>  fieldseparator := ';';
		unit<uint8>        domain : nrofrows = 254;

		parameter<string> filedata
			:   StorageType = "str"
			,   StorageName = "=filename";

		   parameter<string> headerline := readLines(filedata, void, 0);

		   unit<uint32>field := Range(uint32, 0, strcount(headerline, fieldseparator) + 1)
		   {
			  attribute<string> name := ReadArray(headerline , field, string, 0);
		   }
				
		   attribute<string> bodylines (domain) := readLines(filedata, domain, headerline/ReadPos);

		   container data := for_each_nedv(
				  field/name
				 ,'ReadElems(
					 BodyLines
					,string
				   ,'+ MakeDefined(field/name[sub_or_null(id(field),1)] + '/ReadPos','const(0, domain)')+'
				 )'
				 ,domain
				 ,string
			  );
			
			unit<uint32> Glossary:= /Analysis/Calibration/ReadCoffecients/Variables_Glossary;
			
			unit<uint8> rules:= unique(data/rule) {
				attribute<string> Label:= Values;
				attribute<string> name:= asitemname(Label);
				attribute<uint8>  num:= uint8(replace(UpperCase(Label), 'RULE', ''));
				attribute<domain> dataref:= rlookup(Values, data/rule);
				attribute<string> ruledef:= data/Condition[dataref];
				attribute<string> eval:=	data/Eval[dataref];
				
				container iterative_rulesfix:= loop(iter_variable_references, uint16(#Glossary));
				
				template iter_variable_references {
					parameter<uint16> nriter;
					container prevstate:= =nriter = 0[uint16] ? 'rules' : 'iterative_rulesfix/Iter'+string(sub_or_null(nriter, 1[uint16]));
					container nextvalue {
						attribute<string> ruledef (rules):= replace(uppercase(prevstate/ruledef), uppercase(Glossary/Alias[nriter[Glossary]]), uppercase(Glossary/Address[nriter[Glossary]]));
						attribute<string> eval (rules):= replace(uppercase(prevstate/eval), uppercase(Glossary/Alias[nriter[Glossary]]), uppercase(Glossary/Address[nriter[Glossary]]));
					}
		
				}
				
				attribute<string> sanitized_ruledef:= iterative_rulesfix/LastIter/NextValue/ruledef;
				attribute<string> sanitized_eval:= iterative_rulesfix/LastIter/NextValue/eval;
				attribute<string> exec_rules_table:= strlen(sanitized_ruledef) > 0 ? '('+sanitized_ruledef+' ? '+string(num)+'f : 0f)' : '';
				attribute<string> exec_table:= strlen(sanitized_eval) > 0 ? '(float32('+sanitized_ruledef+') * ('+sanitized_eval+'))' : '';
				parameter<string> exec_param:= '('+aslist(exec_table, ' + ')+')'; 
				parameter<string> exec_rules:=  '('+aslist(exec_rules_table, ' + ')+')'; 
				
			}
		}
	template WriteTable32ToCSV
	{
		// begin case parameters
		unit<uint32> table;
		parameter<string> fieldlist;
		parameter<string> filename;
		// end   case parameters

		container impl: isHidden = "True"
		{
			unit<uint32> Field := range(uint32,0,strcount(fieldlist,';')+1)
			{
				attribute<string> FieldDescr  := ReadArray(fieldlist,.,string,0);
				attribute<UInt32> SepPos      := strpos(FieldDescr, ':');
				attribute<string> Name        := IsDefined(SepPos) ? substr(FieldDescr, 0, SepPos): FieldDescr;
				attribute<string> NameInTable := IsDefined(SepPos) ? substr(FieldDescr, SepPos+1, strlen(FieldDescr)) : FieldDescr;
			}
		}
		parameter<string> Header := AsList(Quote(impl/Field/Name),';');
			
		parameter<string> Body_expr := AsList('AsExprList(table/' + impl/Field/NameInTable + ', id(table))',' +'';''+ ');
		attribute<string> Body (table) := =Body_expr;
		parameter<string> Result := Header + '\n' + AsList(Body+'\n', '')
		,	Storagename = "=filename"
		,	StorageType = "str";
	}

	template WriteTable8ToCSV
	{
		// begin case parameters
		unit<uint8> table;
		parameter<string> fieldlist;
		parameter<string> filename;
		// end   case parameters

		container impl: isHidden = "True"
		{
			unit<uint32> Field := range(uint32,0,strcount(fieldlist,';')+1)
			{
				attribute<string> FieldDescr  := ReadArray(fieldlist,.,string,0);
				attribute<UInt32> SepPos      := strpos(FieldDescr, ':');
				attribute<string> Name        := IsDefined(SepPos) ? substr(FieldDescr, 0, SepPos): FieldDescr;
				attribute<string> NameInTable := IsDefined(SepPos) ? substr(FieldDescr, SepPos+1, strlen(FieldDescr)) : FieldDescr;
			}
		}
		parameter<string> Header := AsList(Quote(impl/Field/Name),';');
			
		parameter<string> Body_expr := AsList('AsExprList(table/' + impl/Field/NameInTable + ', id(table))',' +'';''+ ');
		attribute<string> Body (table) := =Body_expr;
		parameter<string> Result := Header + '\n' + AsList(Body+'\n', '')
		,	Storagename = "=filename"
		,	StorageType = "str";
	}
	Template Suitability_T_cubist {
		parameter<string> ThisYear;
		parameter<string> PrevYear;
		container CurrBuState;
		container CurrPopState;
		container Calculate_GridDistances;
		
		unit<wpoint> domain:= Geography/Domain;
		
		unit<uint8> Continents:= /Analysis/Calibration/ReadCoffecients/Read_Cubist/Continental_models;
		
		parameter<string> in_exec:= Continents/exec_param;
		parameter<string> thisyear_exec:= replace(in_exec, 'PREVYEAR', PrevYear);
		
		parameter<string> in_rules:= Continents/exec_rules;
		parameter<string> thisyear_rules:= replace(in_rules, 'PREVYEAR', PrevYear);
		
		attribute<Suit> Prep_Calc (domain) := =thisyear_exec; 
		attribute<Suit> Calc (domain):= Prep_Calc / max_elem(1, rule_eval/nrules)[Suit];
		attribute<Suit> Write_Calc (domain) := Calc, StorageName = "='%LocalDataProjDir%/Temp/'+ModelParameters/StudyArea+'/Suitability_cubist_meaned_'+ModelParameters/Calibration_filedate+'_'+ThisYear+'_'+ModelParameters/domain_EPSG+'.tif'";
		attribute<Suit> Read_Calc  (domain) : StorageName = "='%LocalDataProjDir%/Temp/'+ModelParameters/StudyArea+'/Suitability_cubist_meaned_'+ModelParameters/Calibration_filedate+'_'+ThisYear+'_'+ModelParameters/domain_EPSG+'.tif'", StorageReadOnly = "True";
		
		attribute<float32> Rules (domain):= =thisyear_rules;
		attribute<float32> Write_Rules (domain) := Rules, StorageName = "='%LocalDataProjDir%/Temp/'+ModelParameters/StudyArea+'/Suitability_cubist_ruleset_'+ModelParameters/Calibration_filedate+'_'+ThisYear+'_'+ModelParameters/domain_EPSG+'.tif'";
		
		attribute<Suit>      Prob               (CompactedDomain) := =ModelParameters/Use_TempTifFiles ? 'MakeDefined(max_elem(Read_Calc[CompactedDomain/org_rel], 0f), -100[suit])' : 'MakeDefined(max_elem(Write_Calc[CompactedDomain/org_rel], 0f), -100[suit])';
		
		container rule_eval:= for_each_nedv(Calibration/ReadCoffecients/Read_Cubist/North_America/rules/name, replace(Calibration/ReadCoffecients/Read_Cubist/North_America/rules/sanitized_ruledef, 'PREVYEAR', PrevYear), domain, bool) {
			attribute<uint32> 	nrules (domain):= ='add('+asItemList(strlen(Calibration/ReadCoffecients/Read_Cubist/North_America/rules/name) > 0 ? Calibration/ReadCoffecients/Read_Cubist/North_America/rules/name+'[uint32]' : '')+')',
				StorageName = "='%LocalDataProjDir%/Temp/'+ModelParameters/StudyArea+'/Suitability_cubist_ruleset_rulecount_'+ModelParameters/Calibration_filedate+'_'+ThisYear+'_'+ModelParameters/domain_EPSG+'.tif'";
			attribute<uint32> 	cmax (domain):= ='argmax_ifdefined('+asItemList(strlen(Calibration/ReadCoffecients/Read_Cubist/North_America/rules/name) > 0 ? Calibration/ReadCoffecients/Read_Cubist/North_America/rules/name+'[uint32]' : '')+')',
				StorageName = "='%LocalDataProjDir%/Temp/'+ModelParameters/StudyArea+'/Suitability_cubist_ruleset_maxrule_'+ModelParameters/Calibration_filedate+'_'+ThisYear+'_'+ModelParameters/domain_EPSG+'.tif'";
		}
		
		//attribute<Suit>      CappedBuiltUp         (CompactedDomain) := min_elem(BuiltUp, 80[suit]);
		//attribute<Suit>      expCappedBuiltUp      (CompactedDomain) := exp(CappedBuiltUp);
		//attribute<float32>   Prob                  (CompactedDomain) := expCappedBuiltUp / (1f+ expCappedBuiltUp);
	}
	Template Suitability_T_beta {
		parameter<string> ThisYear;
		parameter<string> PrevYear;
		container CurrBuState;
		container CurrPopState;
		container Calculate_GridDistances;
		
		unit<wpoint> domain:= Geography/Domain;
		
		container        Coeffs            := Analysis/Calibration/ReadCoffecients/beta/coef2domain/domain; 
		
		attribute<Suit> Calc (domain) := ='(CurrPopState/PopulationDensity_8dir/Ln_mean_8dir[float32]                                                 * Coeffs/Ln_PopulationDensity_2000_8dir) + '
										'(min_elem(Physical/Coast/Location2Coast_m_sqr/Result[float32],250f)                                          * Coeffs/Distance2Coastline) + 
										(min_elem(Physical/Water/Location2LargeInlandWater_m_sqr/Result[float32],250f)                                * Coeffs/Distance2LargeInlandWater) + 
										(min_elem(makedefined(Socioeconomic/Infrastructure/Location2Roads45_m_sqr/Result[float32],1000f),250f)        * Coeffs/Distance2SecundaryRoads) + 
										(Calculate_GridDistances/'+PrevYear+'/Grid_costs_atleast_to/villages                		                  * Coeffs/Grid_costs_atleast_to_villages) + 
										(Calculate_GridDistances/'+PrevYear+'/Grid_costs_atleast_to/cities            		                          * Coeffs/Grid_costs_atleast_to_cities) + 
										(Physical/Elevation/Mean_1k[float32]                                                                          * Coeffs/Elevation) + 
										(Physical/Slope_2021/ReadData[float32]                                                                        * Coeffs/Slope) + 
										(makedefined(Physical/TerrainRoughnessIndex/TRI_mean_30ss_World[float32], 0f)                                 * Coeffs/TRI_mean) + 
										(Policy/ProtectedAreas/ReadData[float32]                                                                      * Coeffs/IsProtectedArea) + 
										(Physical/Water/FloodProneArea/RP100/ReadData_Defined[float32]                                                * Coeffs/IsFloodProneArea_RP100) + 
										(Physical/Natural_Hazards/Earthquake/Earthquakes_Modified_Mercalli_Intensity/ReadData[float32]                * Coeffs/Earthquakes_MMI_Index) + 
										(Physical/Natural_Hazards/Landslide/LS_risk[float32]                                                          * Coeffs/LandSlideProne_ARUP) + 
										(recollect_by_cond(domain/IsCompactedDomain, CurrBuState/BuiltUp_Total_Share)[float32]					  	  * Coeffs/CurrBuState)+									
										Coeffs/Intercept'; 
		attribute<Suit> Write_Calc (domain) := Calc, StorageName = "='%LocalDataProjDir%/Temp/'+ModelParameters/StudyArea+'/Suitability_beta'+ModelParameters/Calibration_filedate+'_'+ThisYear+'_'+ModelParameters/domain_EPSG+'.tif'";
		attribute<Suit> Read_Calc  (domain) : StorageName = "='%LocalDataProjDir%/Temp/'+ModelParameters/StudyArea+'/Suitability_beta'+ModelParameters/Calibration_filedate+'_'+ThisYear+'_'+ModelParameters/domain_EPSG+'.tif'", StorageReadOnly = "True";
				
		attribute<Suit>      BuiltUp               (CompactedDomain) := =ModelParameters/Use_TempTifFiles ? 'MakeDefined(Read_Calc[CompactedDomain/org_rel], -100[suit])' : 'MakeDefined(Write_Calc[CompactedDomain/org_rel], -100[suit])';
		attribute<Suit>      CappedBuiltUp         (CompactedDomain) := min_elem(BuiltUp, 80[suit]);
		attribute<Suit>      expCappedBuiltUp      (CompactedDomain) := exp(CappedBuiltUp);
		attribute<float32>   Prob                  (CompactedDomain) := expCappedBuiltUp / (1f+ expCappedBuiltUp);
		
	}
	// glm2 estimated with a probit link (logit implemented)
	Template Suitability_T_GLM2 {
		parameter<string> ThisYear;
		parameter<string> PrevYear;
		container CurrBuState;
		container CurrPopState;
		container Calculate_GridDistances;
		
		unit<wpoint> domain:= Geography/Domain;
		
		container        Coeffs            := Analysis/Calibration/ReadCoffecients/glm2/coef2domain/domain; 
		
		attribute<Suit> Calc (domain) := ='(CurrPopState/PopulationDensity_8dir/Ln_mean_8dir[float32]                                                 * Coeffs/Ln_PopulationDensity_2000_8dir) + '
										'(min_elem(Physical/Coast/Location2Coast_m_sqr/Result[float32],250f)                                          * Coeffs/Distance2Coastline) + 
										(min_elem(Physical/Water/Location2LargeInlandWater_m_sqr/Result[float32],250f)                                * Coeffs/Distance2LargeInlandWater) + 
										(min_elem(makedefined(Socioeconomic/Infrastructure/Location2Roads45_m_sqr/Result[float32],1000f),250f)        * Coeffs/Distance2SecundaryRoads) + 
										(Calculate_GridDistances/'+PrevYear+'/Grid_costs_atleast_to/villages                		                  * Coeffs/Grid_costs_atleast_to_villages) + 
										(Calculate_GridDistances/'+PrevYear+'/Grid_costs_atleast_to/cities            		                          * Coeffs/Grid_costs_atleast_to_cities) + 
										(Physical/Elevation/Mean_1k[float32]                                                                          * Coeffs/Elevation) + 
										(Physical/Slope_2021/ReadData[float32]                                                                        * Coeffs/Slope) + 
										(makedefined(Physical/TerrainRoughnessIndex/TRI_mean_30ss_World[float32], 0f)                                 * Coeffs/TRI_mean) + 
										(Policy/ProtectedAreas/ReadData[float32]                                                                      * Coeffs/IsProtectedArea) + 
										(Physical/Water/FloodProneArea/RP100/ReadData_Defined[float32]                                                * Coeffs/IsFloodProneArea_RP100) + 
										(Physical/Natural_Hazards/Earthquake/Earthquakes_Modified_Mercalli_Intensity/ReadData[float32]                * Coeffs/Earthquakes_MMI_Index) + 
										(Physical/Natural_Hazards/Landslide/LS_risk[float32]                                                          * Coeffs/LandSlideProne_ARUP) + 
										(recollect_by_cond(domain/IsCompactedDomain, CurrBuState/BuiltUp_Total_Share)[float32]					  	  * Coeffs/CurrBuState)+									
										Coeffs/Intercept'; 
		attribute<Suit> Write_Calc (domain) := Calc, StorageName = "='%LocalDataProjDir%/Temp/'+ModelParameters/StudyArea+'/Suitability_GLM2'+ModelParameters/Calibration_filedate+'_'+ThisYear+'_'+ModelParameters/domain_EPSG+'.tif'";
		attribute<Suit> Read_Calc  (domain) : StorageName = "='%LocalDataProjDir%/Temp/'+ModelParameters/StudyArea+'/Suitability_GLM2'+ModelParameters/Calibration_filedate+'_'+ThisYear+'_'+ModelParameters/domain_EPSG+'.tif'", StorageReadOnly = "True";
				
		attribute<Suit>      BuiltUp               (CompactedDomain) := =ModelParameters/Use_TempTifFiles ? 'MakeDefined(Read_Calc[CompactedDomain/org_rel], -100[suit])' : 'MakeDefined(Write_Calc[CompactedDomain/org_rel], -100[suit])';
		attribute<Suit>      CappedBuiltUp         (CompactedDomain) := min_elem(BuiltUp, 80[suit]);
		attribute<Suit>      expCappedBuiltUp      (CompactedDomain) := exp(CappedBuiltUp);
		attribute<float32>   Prob                  (CompactedDomain) := expCappedBuiltUp / (1f+ expCappedBuiltUp);
	}
	
	Template Suitability_T_GLM {
		parameter<string> ThisYear;
		parameter<string> PrevYear;
		container CurrBuState;
		container CurrPopState;
		container Calculate_GridDistances;
		
		
		unit<wpoint> domain:= Geography/Domain;
		
		container        AutoGLM_Coeffs            := Analysis/Calibration/ReadCoffecients/autoglm/coef2domain/domain; 
			
		attribute<Suit> Calc (domain) := ='(CurrPopState/PopulationDensity_8dir/Ln_mean_8dir[float32]                                                                         * AutoGLM_Coeffs/Ln_PopulationDensity_2000_8dir) + '
																'(min_elem(Physical/Coast/Location2Coast_m_sqr/Result[float32],250f)                                          * AutoGLM_Coeffs/Distance2Coastline) + 
																(min_elem(Physical/Water/Location2LargeInlandWater_m_sqr/Result[float32],250f)                                * AutoGLM_Coeffs/Distance2LargeInlandWater) + 
																(min_elem(makedefined(Socioeconomic/Infrastructure/Location2Roads45_m_sqr/Result[float32],1000f),250f)        * AutoGLM_Coeffs/Distance2SecundaryRoads) + 
																(Calculate_GridDistances/'+PrevYear+'/Grid_costs_atleast_to/villages                		                  * AutoGLM_Coeffs/gc_villages) + 
																(Calculate_GridDistances/'+PrevYear+'/Grid_costs_atleast_to/cities            		                          * AutoGLM_Coeffs/gc_cities) + 
																(Physical/Elevation/Mean_1k[float32]                                                                          * AutoGLM_Coeffs/Elevation) + 
																(Physical/Slope_2021/ReadData[float32]                                                                        * AutoGLM_Coeffs/Slope) + 
																(makedefined(Physical/TerrainRoughnessIndex/TRI_mean_30ss_World[float32], 0f)                                 * AutoGLM_Coeffs/TRI_mean) + 
																(Policy/ProtectedAreas/ReadData[float32]                                                                      * AutoGLM_Coeffs/IsProtectedArea) + 
																(Physical/Water/FloodProneArea/RP100/ReadData_Defined[float32]                                                * AutoGLM_Coeffs/IsFloodProneArea_RP100) + 
																(Physical/Natural_Hazards/Earthquake/Earthquakes_Modified_Mercalli_Intensity/ReadData[float32]                * AutoGLM_Coeffs/Earthquakes_MMI_Index) + 
																(Physical/Natural_Hazards/Landslide/LS_risk[float32]                                                          * AutoGLM_Coeffs/Landslide_Prone) + 
																AutoGLM_Coeffs/Intercept'; 
		attribute<Suit> Write_Calc (domain) := Calc, StorageName = "='%LocalDataProjDir%/Temp/'+ModelParameters/StudyArea+'/Suitability_GLM'+ModelParameters/Calibration_filedate+'_'+ThisYear+'_'+ModelParameters/domain_EPSG+'.tif'";
		attribute<Suit> Read_Calc  (domain) : StorageName = "='%LocalDataProjDir%/Temp/'+ModelParameters/StudyArea+'/Suitability_GLM'+ModelParameters/Calibration_filedate+'_'+ThisYear+'_'+ModelParameters/domain_EPSG+'.tif'", StorageReadOnly = "True";
				
		attribute<Suit>      BuiltUp               (CompactedDomain) := =ModelParameters/Use_TempTifFiles ? 'MakeDefined(Read_Calc[CompactedDomain/org_rel], -100[suit])' : 'MakeDefined(Write_Calc[CompactedDomain/org_rel], -100[suit])';
		attribute<Suit>      CappedBuiltUp         (CompactedDomain) := min_elem(BuiltUp, 80[suit]);
		attribute<Suit>      expCappedBuiltUp      (CompactedDomain) := exp(CappedBuiltUp);
		attribute<float32>   Prob                  (CompactedDomain) := expCappedBuiltUp / (1f+ expCappedBuiltUp);
	}
}