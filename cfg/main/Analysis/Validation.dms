container Validation : using = "units;geography;sourcedata/regionalunits;classifications"
{
	parameter<string> StartYear := 'Y2000';
	parameter<string> ModelYear := 'Y2020';
	
	unit<uint8> ValidationYears:= range(uint8, 0b, 2b) {
		attribute<uint32> Year:= 2000 + (1+uint32(id(.)))*10;
		attribute<string> name:= 'Y'+string(Year);
		attribute<string> prev_name      := id(.) != first(id(.)) ? name[id(.) - min_elem( id(.), 1b) ] : Validation/StartYear;
		attribute<string> prevStateName  := id(.) != first(id(.)) ? name[id(.) - min_elem( id(.), 1b) ]+'/NewState' : 'InitialState';
	}
	
	container InitialState:= Future/InitialState_T(Validation/StartYear);
		
	unit<uint32> ClaimRegion := FunctionalAreas;

	container Claim
	{
		container Builtup    := Preprocessing/Claims_BuiltUp;
		container Population := Preprocessing/Claims_Population;
	}
	unit<uint32> export:= CompactedDomain {
		attribute<float32> buperctot00:= Validation/InitialState/BuiltUp_Total_Area;
		attribute<float32> buperctot20:= Future/InitialState/BuiltUp_Total_Area;
		attribute<float32> proxy_autoglm:= autoglm/Suitability/Y2010/FinalProb;
		attribute<float32> suit_beta:= beta/Suitability/Y2010/FinalProb;
		attribute<float32> suit_glm2:= GLM2/Suitability/Y2010/FinalProb;
		attribute<float32> suit_cubist:= cubist/Suitability/Y2010/FinalProb;
	}
	container AutoGLM {
		container Suitability:= for_each_ne(ValidationYears/name, 'Templates/Suitability_T_GLM('
			+quote(ValidationYears/name)+
			','+quote(ValidationYears/prev_name)+ 
			', Allocate_Builtup/'+ValidationYears/prevStateName+
			', Allocate_Population/'+ValidationYears/prevStateName+
			', Claim/Builtup/'+ValidationYears/name+                   
			', Validation/AutoGLM/Calculate_GridDistances'+')'	
		);
		container Allocate_Builtup := 
			for_each_ne(
				ValidationYears/name 
				,	'Future/Allocate_Builtup_T('
						+quote(ValidationYears/name)+                              // (0) Year
						','+quote(ValidationYears/prev_name)+                      // (1) PrevYear
						', Allocate_Builtup/'+ValidationYears/prevStateName+       // (2) State builtup of previous period
						', Suitability/'+ValidationYears/name+    				   // (3) Suitability container
						', Claim/Builtup/'+ValidationYears/name+                   // (4) Expected amount of builtup per region in km2
					')'
			) 
		{
			container InitialState:= Validation/InitialState;
			container Y2020_onestep:= Future/Allocate_Builtup_T('Y2020','Y2000', Allocate_Builtup/InitialState , Suitability/Y2010 , Claim/Builtup/Y2020);
		}
		container Allocate_Population := 
			for_each_ne(
				ValidationYears/name 
				,	'Future/Allocate_Population_T('
						+quote(ValidationYears/name)+								// (0) Year
						','+quote(ValidationYears/prev_name)+						// (1) PrevYear
						','+ValidationYears/prevStateName+							// (2) State population of previous period
						', Allocate_Builtup/'+ValidationYears/name+'/CurrState'	    // (3) State builtup of previous period
						', Allocate_Builtup/'+ValidationYears/name+'/NewState'		// (4) State builtup of current period
						', Suitability/'+ValidationYears/name+    				    // (5) Suitability container
						', Claim/Population/'+ValidationYears/name+					// (6) Expected amount of population per region
					')'
			) 
		{
			container InitialState:= Validation/InitialState;
			container Y2020_onestep:= Future/Allocate_Population_T('Y2020','Y2000',InitialState, Allocate_Builtup/Y2020_onestep/CurrState, Allocate_Builtup/Y2020_onestep/NewState, Suitability/Y2010, Claim/Population/Y2010);
		}
		container Store_Results:= T_Store_Results('vali_AutoGLM_');

		container Calculate_GridDistances := 
			for_each_ne(
				ValidationYears/name
				, ModelParameters/Use_TempTifFiles 
					? 'Preprocessing/Calculate_GridDistances/T_AllVariants_Instantiation(Store_Results/DegreesOfUrbanisation/'+ValidationYears/name+'/ReadTypologyK)' 
					: 'Preprocessing/Calculate_GridDistances/T_AllVariants_Instantiation(Store_Results/DegreesOfUrbanisation/'+ValidationYears/name+'/Typology_Domain)'
			)
		{container Y2000 := /Preprocessing/GridDistances/Y2000;}
	}
	container beta {
		container Suitability:= for_each_ne(ValidationYears/name, 'Templates/Suitability_T_beta('
			+quote(ValidationYears/name)+
			','+quote(ValidationYears/prev_name)+ 
			', Allocate_Builtup/'+ValidationYears/prevStateName+
			', Allocate_Population/'+ValidationYears/prevStateName+
			', Validation/beta/Calculate_GridDistances'+')'	
		);
		container Allocate_Builtup := 
			for_each_ne(
				ValidationYears/name 
				,	'Future/Allocate_Builtup_T('
						+quote(ValidationYears/name)+                              // (0) Year
						','+quote(ValidationYears/prev_name)+                      // (1) PrevYear
						', Allocate_Builtup/'+ValidationYears/prevStateName+       // (2) State builtup of previous period
						', Suitability/'+ValidationYears/name+    				   // (3) Suitability container
						', Claim/Builtup/'+ValidationYears/name+                   // (4) Expected amount of builtup per region in km2
					')'
			) 
		{
			container InitialState:= Validation/InitialState;
			container Y2020_onestep:= Future/Allocate_Builtup_T('Y2020','Y2000', Allocate_Builtup/InitialState , Suitability/Y2010 , Claim/Builtup/Y2020);
		}
		container Allocate_Population := 
			for_each_ne(
				ValidationYears/name 
				,	'Future/Allocate_Population_T('
						+quote(ValidationYears/name)+								// (0) Year
						','+quote(ValidationYears/prev_name)+						// (1) PrevYear
						','+ValidationYears/prevStateName+							// (2) State population of previous period
						', Allocate_Builtup/'+ValidationYears/name+'/CurrState'	    // (3) State builtup of previous period
						', Allocate_Builtup/'+ValidationYears/name+'/NewState'		// (4) State builtup of current period
						', Suitability/'+ValidationYears/name+    				    // (5) Suitability container
						', Claim/Population/'+ValidationYears/name+					// (6) Expected amount of population per region
					')'
			) 
		{
			container InitialState:= Validation/InitialState;
			container Y2020_onestep:= Future/Allocate_Population_T('Y2020','Y2000',InitialState, Allocate_Builtup/Y2020_onestep/CurrState, Allocate_Builtup/Y2020_onestep/NewState, Suitability/Y2010, Claim/Population/Y2010);
		}
		container Store_Results:= T_Store_Results('vali_beta_');

		container Calculate_GridDistances := 
			for_each_ne(
				ValidationYears/name
				, ModelParameters/Use_TempTifFiles 
					? 'Preprocessing/Calculate_GridDistances/T_AllVariants_Instantiation(Store_Results/DegreesOfUrbanisation/'+ValidationYears/name+'/ReadTypologyK)' 
					: 'Preprocessing/Calculate_GridDistances/T_AllVariants_Instantiation(Store_Results/DegreesOfUrbanisation/'+ValidationYears/name+'/Typology_Domain)'
			)
		{container Y2000 := /Preprocessing/GridDistances/Y2000;}
	}
	container GLM2 {
		container Suitability:= for_each_ne(ValidationYears/name, 'Templates/Suitability_T_GLM2('
			+quote(ValidationYears/name)+
			','+quote(ValidationYears/prev_name)+ 
			', Allocate_Builtup/'+ValidationYears/prevStateName+
			', Allocate_Population/'+ValidationYears/prevStateName+
			', Validation/GLM2/Calculate_GridDistances'+')'	
		);
		container Allocate_Builtup := 
			for_each_ne(
				ValidationYears/name 
				,	'Future/Allocate_Builtup_T('
						+quote(ValidationYears/name)+                              // (0) Year
						','+quote(ValidationYears/prev_name)+                      // (1) PrevYear
						', Allocate_Builtup/'+ValidationYears/prevStateName+       // (2) State builtup of previous period
						', Suitability/'+ValidationYears/name+    				   // (3) Suitability container
						', Claim/Builtup/'+ValidationYears/name+                   // (4) Expected amount of builtup per region in km2
					')'
			) 
		{
			container InitialState:= Validation/InitialState;
			container Y2020_onestep:= Future/Allocate_Builtup_T('Y2020','Y2000', Allocate_Builtup/InitialState , Suitability/Y2010 , Claim/Builtup/Y2020);
		}
		container Allocate_Population := 
			for_each_ne(
				ValidationYears/name 
				,	'Future/Allocate_Population_T('
						+quote(ValidationYears/name)+								// (0) Year
						','+quote(ValidationYears/prev_name)+						// (1) PrevYear
						','+ValidationYears/prevStateName+							// (2) State population of previous period
						', Allocate_Builtup/'+ValidationYears/name+'/CurrState'	    // (3) State builtup of previous period
						', Allocate_Builtup/'+ValidationYears/name+'/NewState'		// (4) State builtup of current period
						', Suitability/'+ValidationYears/name+    				    // (5) Suitability container
						', Claim/Population/'+ValidationYears/name+					// (6) Expected amount of population per region
					')'
			) 
		{
			container InitialState:= Validation/InitialState;
			container Y2020_onestep:= Future/Allocate_Population_T('Y2020','Y2000',InitialState, Allocate_Builtup/Y2020_onestep/CurrState, Allocate_Builtup/Y2020_onestep/NewState, Suitability/Y2010, Claim/Population/Y2010);
		}
		container Store_Results:= T_Store_Results('vali_GLM2_');

		container Calculate_GridDistances := 
			for_each_ne(
				ValidationYears/name
				, ModelParameters/Use_TempTifFiles 
					? 'Preprocessing/Calculate_GridDistances/T_AllVariants_Instantiation(Store_Results/DegreesOfUrbanisation/'+ValidationYears/name+'/ReadTypologyK)' 
					: 'Preprocessing/Calculate_GridDistances/T_AllVariants_Instantiation(Store_Results/DegreesOfUrbanisation/'+ValidationYears/name+'/Typology_Domain)'
			)
		{container Y2000 := /Preprocessing/GridDistances/Y2000;}
	}
	container cubist {
		container Suitability:= for_each_ne(ValidationYears/name, 'Templates/Suitability_T_cubist('
			+quote(ValidationYears/name)+
			','+quote(ValidationYears/prev_name)+ 
			', Allocate_Builtup/'+ValidationYears/prevStateName+
			', Allocate_Population/'+ValidationYears/prevStateName+
			', Validation/cubist/Calculate_GridDistances'+')'	
		);
		container Allocate_Builtup := 
			for_each_ne(
				ValidationYears/name 
				,	'Future/Allocate_Builtup_T('
						+quote(ValidationYears/name)+                              // (0) Year
						','+quote(ValidationYears/prev_name)+                      // (1) PrevYear
						', Allocate_Builtup/'+ValidationYears/prevStateName+       // (2) State builtup of previous period
						', Suitability/'+ValidationYears/name+    				   // (3) Suitability container
						', Claim/Builtup/'+ValidationYears/name+                   // (4) Expected amount of builtup per region in km2
					')'
			) 
		{
			container InitialState:= Validation/InitialState;
			container Y2020_onestep:= Future/Allocate_Builtup_T('Y2020','Y2000', Allocate_Builtup/InitialState , Suitability/Y2010 , Claim/Builtup/Y2020);
		}
		container Allocate_Population := 
			for_each_ne(
				ValidationYears/name 
				,	'Future/Allocate_Population_T('
						+quote(ValidationYears/name)+								// (0) Year
						','+quote(ValidationYears/prev_name)+						// (1) PrevYear
						','+ValidationYears/prevStateName+							// (2) State population of previous period
						', Allocate_Builtup/'+ValidationYears/name+'/CurrState'	    // (3) State builtup of previous period
						', Allocate_Builtup/'+ValidationYears/name+'/NewState'		// (4) State builtup of current period
						', Suitability/'+ValidationYears/name+    				    // (5) Suitability container
						', Claim/Population/'+ValidationYears/name+					// (6) Expected amount of population per region
					')'
			) 
		{
			container InitialState:= Validation/InitialState;
			container Y2020_onestep:= Future/Allocate_Population_T('Y2020','Y2000',InitialState, Allocate_Builtup/Y2020_onestep/CurrState, Allocate_Builtup/Y2020_onestep/NewState, Suitability/Y2010, Claim/Population/Y2010);
		}
		container Store_Results:= T_Store_Results('vali_cubist_');

		container Calculate_GridDistances := for_each_ne(
			ValidationYears/name
			, ModelParameters/Use_TempTifFiles 
				? 'Preprocessing/Calculate_GridDistances/T_AllVariants_Instantiation(Store_Results/DegreesOfUrbanisation/'+ValidationYears/name+'/ReadTypologyK)' 
				: 'Preprocessing/Calculate_GridDistances/T_AllVariants_Instantiation(Store_Results/DegreesOfUrbanisation/'+ValidationYears/name+'/Typology_Domain)'
		) {container Y2000 := /Preprocessing/GridDistances/Y2000;}	
	}
	container prevbustate {
		container Suitability:= for_each_ne(ValidationYears/name, 'Templates/Suitability_T_PriorBUstate('
			+quote(ValidationYears/name)+
			','+quote(ValidationYears/prev_name)+ 
			', Allocate_Builtup/'+ValidationYears/prevStateName+
			', Allocate_Population/'+ValidationYears/prevStateName+')'	
		);
		container Allocate_Builtup := 
			for_each_ne(
				ValidationYears/name 
				,	'Future/Allocate_Builtup_T('
						+quote(ValidationYears/name)+                              // (0) Year
						','+quote(ValidationYears/prev_name)+                      // (1) PrevYear
						', Allocate_Builtup/'+ValidationYears/prevStateName+       // (2) State builtup of previous period
						', Suitability/'+ValidationYears/name+    				   // (3) Suitability container
						', Claim/Builtup/'+ValidationYears/name+                   // (4) Expected amount of builtup per region in km2
					')'
			) 
		{
			container InitialState:= Validation/InitialState;
			container Y2020_onestep:= Future/Allocate_Builtup_T('Y2020','Y2000', Allocate_Builtup/InitialState , Suitability/Y2010 , Claim/Builtup/Y2020);
		}
		container Allocate_Population := 
			for_each_ne(
				ValidationYears/name 
				,	'Future/Allocate_Population_T('
						+quote(ValidationYears/name)+								// (0) Year
						','+quote(ValidationYears/prev_name)+						// (1) PrevYear
						','+ValidationYears/prevStateName+							// (2) State population of previous period
						', Allocate_Builtup/'+ValidationYears/name+'/CurrState'	    // (3) State builtup of previous period
						', Allocate_Builtup/'+ValidationYears/name+'/NewState'		// (4) State builtup of current period
						', Suitability/'+ValidationYears/name+    				    // (5) Suitability container
						', Claim/Population/'+ValidationYears/name+					// (6) Expected amount of population per region
					')'
			) 
		{
			container InitialState:= Validation/InitialState;
			container Y2020_onestep:= Future/Allocate_Population_T('Y2020','Y2000',InitialState, Allocate_Builtup/Y2020_onestep/CurrState, Allocate_Builtup/Y2020_onestep/NewState, Suitability/Y2010, Claim/Population/Y2010);
		}
		container Store_Results:= T_Store_Results('vali_prevbustate_');

		container Calculate_GridDistances := for_each_ne(
			ValidationYears/name
			, ModelParameters/Use_TempTifFiles 
				? 'Preprocessing/Calculate_GridDistances/T_AllVariants_Instantiation(Store_Results/DegreesOfUrbanisation/'+ValidationYears/name+'/ReadTypologyK)' 
				: 'Preprocessing/Calculate_GridDistances/T_AllVariants_Instantiation(Store_Results/DegreesOfUrbanisation/'+ValidationYears/name+'/Typology_Domain)'
		) {container Y2000 := /Preprocessing/GridDistances/Y2000;}	
	}
	Template T_Store_Results {
		parameter<string> file_addition;
		container DegreesOfUrbanisation :=
			for_each_ne(
				ValidationYears/name
				 , 'Preprocessing/Calculate_DegreeOfUrbanisation/Gen_T(
						'+quote(file_addition+ValidationYears/name)+'
						 , recollect_by_cond(domain/IsCompactedDomain, convert(Allocate_Builtup/'+ValidationYears/name+'/NewState/BuiltUp_Total_Area, float32)[km2])
						 , recollect_by_cond(domain/IsCompactedDomain, Allocate_Builtup/'+ValidationYears/name+'/NewState/BuiltUp_Residential_Area[km2])
						 , recollect_by_cond(domain/IsCompactedDomain, Allocate_Population/'+ValidationYears/name+'/NewState/Population[Person]))'
			)
		{
			container Initial:= Y2000;
			container Y2000
			{
				attribute<TypologyK>       Typology_Domain                                   (domain) := ='Preprocessing/DegreesOfUrbanisation/'+Validation/StartYear+'/Typology_Domain';
				attribute<TypologyK>       ReadTypologyK                                     (domain) := ='Preprocessing/DegreesOfUrbanisation/'+Validation/StartYear+'/ReadTypologyK';
			}
		}
		unit<wpoint> ModelResults:= domain {
			attribute<float32> bu_Y2020			:= Allocate_Builtup/Y2020/NewState/BuiltUp_Total_Area[CompactedDomain/BaseGrid], storagename = "= '%LocalDataProjDir%/Results/Validation/'+ModelParameters/StudyArea+'/Builtup_2020_'+file_addition+'_'+ModelParameters/domain_EPSG+'.tif'", storagetype = "gdalwrite.grid";
			attribute<float32> bu_Y2020_onestep := Allocate_Builtup/Y2020_onestep/NewState/BuiltUp_Total_Area[CompactedDomain/BaseGrid], storagename = "= '%LocalDataProjDir%/Results/Validation/'+ModelParameters/StudyArea+'/Builtup_2020_onestep_'+file_addition+'_'+ModelParameters/domain_EPSG+'.tif'", storagetype = "gdalwrite.grid";
			attribute<int32> pop_Y2020 			:= Allocate_Population/Y2020/NewState/Population[CompactedDomain/BaseGrid], storagename = "= '%LocalDataProjDir%/Results/Validation/'+ModelParameters/StudyArea+'/Pop_2020_'+file_addition+'_'+ModelParameters/domain_EPSG+'.tif'", storagetype = "gdalwrite.grid";
			attribute<int32> pop_Y2020_onestep  := Allocate_Population/Y2020_onestep/NewState/Population[CompactedDomain/BaseGrid], storagename = "= '%LocalDataProjDir%/Results/Validation/'+ModelParameters/StudyArea+'/Pop_2020_onestep_'+file_addition+'_'+ModelParameters/domain_EPSG+'.tif'", storagetype = "gdalwrite.grid";
		}
		unit<wpoint> ModelResults_readonly:= ModelResults {
			attribute<float32> bu_Y2020: storagename = "= propvalue(ModelResults/bu_Y2020, 'storagename')", storagereadonly="true", storagetype = "gdal.grid";
			attribute<float32> bu_Y2020_onestep: storagename = "= propvalue(ModelResults/bu_Y2020_onestep, 'storagename')", storagereadonly="true", storagetype = "gdal.grid";
			attribute<int32> pop_Y2020: storagename = "= propvalue(ModelResults/pop_Y2020, 'storagename')", storagereadonly="true", storagetype = "gdal.grid";
			attribute<int32> pop_Y2020_onestep: storagename = "= propvalue(ModelResults/pop_Y2020_onestep, 'storagename')", storagereadonly="true", storagetype = "gdal.grid";
		}
	}
	
	container Indicators
	{
		attribute<BuiltUpKm2> Observed_Builtup          (CompactedDomain) := ='(SourceData/BuiltUp/Total/'+ModelYear+'[km2] / 1[km2] * 1[BuiltUpKm2])[CompactedDomain/org_rel]';
		
		//results from modelling
		attribute<float32> Modelled_Builtup_AutoGLM   	(CompactedDomain) := AutoGLM/Store_Results/ModelResults_readonly/bu_Y2020[CompactedDomain/org_rel];
		attribute<float32> Modelled_Builtup_AutoGLM_os	(CompactedDomain) := AutoGLM/Store_Results/ModelResults_readonly/bu_Y2020_onestep[CompactedDomain/org_rel];
		attribute<float32> Modelled_Builtup_Beta 	  	(CompactedDomain) := beta/Store_Results/ModelResults_readonly/bu_Y2020[CompactedDomain/org_rel];
		attribute<float32> Modelled_Builtup_Beta_os		(CompactedDomain) := beta/Store_Results/ModelResults_readonly/bu_Y2020_onestep[CompactedDomain/org_rel];
		attribute<float32> Modelled_Builtup_GLM2	  	(CompactedDomain) := GLM2/Store_Results/ModelResults_readonly/bu_Y2020[CompactedDomain/org_rel];
		attribute<float32> Modelled_Builtup_GLM2_os		(CompactedDomain) := GLM2/Store_Results/ModelResults_readonly/bu_Y2020_onestep[CompactedDomain/org_rel];
		attribute<float32> Modelled_Builtup_cubist	  	(CompactedDomain) := cubist/Store_Results/ModelResults_readonly/bu_Y2020[CompactedDomain/org_rel];
		attribute<float32> Modelled_Builtup_cubist_os	(CompactedDomain) := cubist/Store_Results/ModelResults_readonly/bu_Y2020_onestep[CompactedDomain/org_rel];
		attribute<float32> Modelled_Builtup_prevbu	  	(CompactedDomain) := prevbustate/Store_Results/ModelResults_readonly/bu_Y2020[CompactedDomain/org_rel];
		attribute<float32> Modelled_Builtup_prevbu_os	(CompactedDomain) := prevbustate/Store_Results/ModelResults_readonly/bu_Y2020_onestep[CompactedDomain/org_rel];
		
		//abs errors
		attribute<float32>    ObservedMINUSModelled_BU_AutoGLM  	(CompactedDomain) := (Modelled_Builtup_AutoGLM - Observed_Builtup);
		attribute<float32>    ObservedMINUSModelled_BU_AutoGLM_os  	(CompactedDomain) := (Modelled_Builtup_AutoGLM_os - Observed_Builtup);
		attribute<float32>    ObservedMINUSModelled_BU_Beta  		(CompactedDomain) := (Modelled_Builtup_Beta - Observed_Builtup);
		attribute<float32>    ObservedMINUSModelled_BU_Beta_os  	(CompactedDomain) := (Modelled_Builtup_Beta_os - Observed_Builtup);
		attribute<float32>    ObservedMINUSModelled_BU_GLM2  		(CompactedDomain) := (Modelled_Builtup_GLM2 - Observed_Builtup);
		attribute<float32>    ObservedMINUSModelled_BU_GLM2_os  	(CompactedDomain) := (Modelled_Builtup_GLM2_os - Observed_Builtup);
		attribute<float32>    ObservedMINUSModelled_BU_cubist  		(CompactedDomain) := (Modelled_Builtup_cubist - Observed_Builtup);
		attribute<float32>    ObservedMINUSModelled_BU_cubist_os  	(CompactedDomain) := (Modelled_Builtup_cubist_os - Observed_Builtup);
		attribute<float32>    ObservedMINUSModelled_BU_prevbu  		(CompactedDomain) := (Modelled_Builtup_prevbu - Observed_Builtup);
		attribute<float32>    ObservedMINUSModelled_BU_prevbu_os  	(CompactedDomain) := (Modelled_Builtup_prevbu_os - Observed_Builtup);
		
		
		attribute<Person>     Observed_Population       (CompactedDomain) := ='(SourceData/Population/PerYear/'+ModelYear+'[Person])[CompactedDomain/org_rel]';
		attribute<Person>     Modelled_Population       (CompactedDomain) := Allocate_Population/NewState/Population;
	
		attribute<float32>    ObservedMINUSModelled_Pop (CompactedDomain) := abs(Observed_Population - Modelled_Population);
		attribute<float32>    ObservedMINUSModelled_BU  (CompactedDomain) := abs(Observed_Builtup - Modelled_Builtup);
		
		attribute<bool>       IsBU_where_BU_ShouldBe    (CompactedDomain) := Observed_Builtup > 0[BuiltUpKm2] && Modelled_Builtup > 0[BuiltUpKm2] || Observed_Builtup == Modelled_Builtup;
		attribute<bool>       IsPop_where_Pop_ShouldBe  (CompactedDomain) := Observed_Population > 0[Person] && Modelled_Population > 0[Person] || Observed_Population == Modelled_Population;
		
		attribute<bool>       IsBU_without_Pop          (CompactedDomain) := Modelled_Builtup > 0[BuiltUpKm2] && Modelled_Population == 0[Person];
		attribute<bool>       HasPop_without_BU         (CompactedDomain) := Modelled_Population > 0[Person] && Modelled_Builtup == 0[BuiltUpKm2];
		
		parameter<float32>	  MAPE_AutoGLM:= sum(abs(ObservedMINUSModelled_BU_AutoGLM)) / sum(Observed_Builtup);
		parameter<float32>	  MAPE_AutoGLM_os:= sum(abs(ObservedMINUSModelled_BU_AutoGLM_os)) / sum(Observed_Builtup);
		parameter<float32>    MAPE_Beta:= sum(abs(ObservedMINUSModelled_BU_Beta)) / sum(Observed_Builtup);
		parameter<float32>    MAPE_Beta_os:= sum(abs(ObservedMINUSModelled_BU_Beta_os)) / sum(Observed_Builtup);
		parameter<float32>    MAPE_GLM2:= sum(abs(ObservedMINUSModelled_BU_GLM2)) / sum(Observed_Builtup);
		parameter<float32>    MAPE_GLM2_os:= sum(abs(ObservedMINUSModelled_BU_GLM2_os)) / sum(Observed_Builtup);
		parameter<float32>    MAPE_cubist:= sum(abs(ObservedMINUSModelled_BU_cubist)) / sum(Observed_Builtup);
		parameter<float32>    MAPE_cubist_os:= sum(abs(ObservedMINUSModelled_BU_cubist_os)) / sum(Observed_Builtup);
		parameter<float32>    MAPE_prevbu:= sum(abs(ObservedMINUSModelled_BU_prevbu)) / sum(Observed_Builtup);
		parameter<float32>    MAPE_prevbu_os:= sum(abs(ObservedMINUSModelled_BU_prevbu_os)) / sum(Observed_Builtup);
		
		unit<wpoint> export:= domain {
			attribute<float32> AutoGLM:= 	ObservedMINUSModelled_BU_AutoGLM[CompactedDomain/BaseGrid], storagename = "= '%LocalDataProjDir%/Results/Validation_export/d_'+ModelParameters/StudyArea+'/Builtup_2020_AutoGLM_'+ModelParameters/domain_EPSG+'.tif'", storagetype = "gdalwrite.grid";
			attribute<float32> Beta:= 		ObservedMINUSModelled_BU_Beta[CompactedDomain/BaseGrid], storagename = "= '%LocalDataProjDir%/Results/Validation_export/d_'+ModelParameters/StudyArea+'/Builtup_2020_Beta_'+ModelParameters/domain_EPSG+'.tif'", storagetype = "gdalwrite.grid";
			attribute<float32> GLM2:= 		ObservedMINUSModelled_BU_GLM2[CompactedDomain/BaseGrid], storagename = "= '%LocalDataProjDir%/Results/Validation_export/d_'+ModelParameters/StudyArea+'/Builtup_2020_GLM2_'+ModelParameters/domain_EPSG+'.tif'", storagetype = "gdalwrite.grid";
			attribute<float32> cubist:= 	ObservedMINUSModelled_BU_cubist[CompactedDomain/BaseGrid], storagename = "= '%LocalDataProjDir%/Results/Validation_export/d_'+ModelParameters/StudyArea+'/Builtup_2020_cubist_'+ModelParameters/domain_EPSG+'.tif'", storagetype = "gdalwrite.grid";
			attribute<float32> prevbustate:=ObservedMINUSModelled_BU_prevbu[CompactedDomain/BaseGrid], storagename = "= '%LocalDataProjDir%/Results/Validation_export/d_'+ModelParameters/StudyArea+'/Builtup_2020_prevbustate_'+ModelParameters/domain_EPSG+'.tif'", storagetype = "gdalwrite.grid";
		}
		
		unit<uint32> Per_FA := FunctionalAreas 
		{
			attribute<string>   Name                          := FunctionalAreas/label;
			attribute<float32>  MAPE_Builtup                  := 100f * (1f / count(Modelled_Builtup, CompactedDomain/FunctionalAreas_rel)[float32]) * sum( abs(ObservedMINUSModelled_BU / Observed_Builtup), CompactedDomain/FunctionalAreas_rel), Descr = "Mean Absolute Percentage Error: a measure used to evaluate the accuracy of a forecasting model. It expresses the accuracy as a percentage. Interpretation: Lower MAPE: Indicates a better fitting model, as the errors are smaller in comparison to the actual values. Higher MAPE: Suggests a less accurate model, with larger errors relative to the actual values.";
			attribute<float32>  MAPE_Pop                      := 100f * (1f / count(Modelled_Population, CompactedDomain/FunctionalAreas_rel)[float32]) * sum( abs(ObservedMINUSModelled_Pop / Observed_Population), CompactedDomain/FunctionalAreas_rel), Descr = "Mean Absolute Percentage Error: a measure used to evaluate the accuracy of a forecasting model. It expresses the accuracy as a percentage. Interpretation: Lower MAPE: Indicates a better fitting model, as the errors are smaller in comparison to the actual values. Higher MAPE: Suggests a less accurate model, with larger errors relative to the actual values.";
			
			attribute<float32>  PercOf_CorrectCellsWithAnyBU  := sum(IsBU_where_BU_ShouldBe[float32], CompactedDomain/FunctionalAreas_rel)[float32] / count(Modelled_Builtup, CompactedDomain/FunctionalAreas_rel)[float32];
			attribute<float32>  PercOf_CorrectCellsWithAnyPop := sum(IsPop_where_Pop_ShouldBe[float32], CompactedDomain/FunctionalAreas_rel)[float32] / count(Modelled_Population, CompactedDomain/FunctionalAreas_rel)[float32];
			
			attribute<float32>  PercOf_CellsBU_withoutPop     := sum(IsBU_without_Pop[float32], CompactedDomain/FunctionalAreas_rel)[float32] / count(Modelled_Builtup, CompactedDomain/FunctionalAreas_rel)[float32];
			attribute<float32>  PercOf_CellsPop_withoutBU     := sum(HasPop_without_BU[float32], CompactedDomain/FunctionalAreas_rel)[float32] / count(Modelled_Population, CompactedDomain/FunctionalAreas_rel)[float32];
			
		}
	}
}